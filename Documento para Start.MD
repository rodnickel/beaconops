\# ğŸ“‹ Project Brief: Plataforma de Monitoramento e Observabilidade



\## ğŸ¯ VisÃ£o Geral



Estou desenvolvendo uma plataforma de monitoramento e observabilidade similar ao Better Stack. O objetivo Ã© criar uma soluÃ§Ã£o completa que inicialmente serÃ¡ usada internamente na minha empresa, mas com potencial de se tornar um produto comercial (SaaS).



\*\*NÃ­vel tÃ©cnico do desenvolvedor:\*\* Iniciante/IntermediÃ¡rio â€” preciso de explicaÃ§Ãµes claras e cÃ³digo bem comentado.



---



\## ğŸ› ï¸ Stack TecnolÃ³gica Definida



\### Backend

\- \*\*Runtime:\*\* Node.js 20+ com TypeScript

\- \*\*Framework:\*\* Fastify

\- \*\*ORM:\*\* Prisma

\- \*\*ValidaÃ§Ã£o:\*\* Zod

\- \*\*AutenticaÃ§Ã£o:\*\* JWT + bcrypt



\### Banco de Dados

\- \*\*Principal:\*\* PostgreSQL

\- \*\*Cache/Filas:\*\* Redis (para agendamento de jobs)

\- \*\*Job Queue:\*\* BullMQ (baseado em Redis)



\### Frontend

\- \*\*Framework:\*\* Next.js 14 (App Router)

\- \*\*Linguagem:\*\* TypeScript

\- \*\*EstilizaÃ§Ã£o:\*\* Tailwind CSS

\- \*\*Componentes:\*\* shadcn/ui

\- \*\*GrÃ¡ficos:\*\* Recharts

\- \*\*Estado:\*\* Zustand (se necessÃ¡rio)



\### Infraestrutura

\- \*\*Backend + DB:\*\* Railway ou Render

\- \*\*Frontend:\*\* Vercel

\- \*\*Emails:\*\* Resend

\- \*\*DNS (futuro):\*\* Cloudflare



---



\## ğŸ—ï¸ Arquitetura do Projeto



```

projeto/

â”œâ”€â”€ apps/

â”‚   â”œâ”€â”€ api/                 # Backend Fastify

â”‚   â”‚   â”œâ”€â”€ src/

â”‚   â”‚   â”‚   â”œâ”€â”€ modules/     # MÃ³dulos por domÃ­nio

â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth/

â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ monitors/

â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ alerts/

â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ incidents/

â”‚   â”‚   â”‚   â”‚   â””â”€â”€ status-pages/

â”‚   â”‚   â”‚   â”œâ”€â”€ jobs/        # Workers de verificaÃ§Ã£o

â”‚   â”‚   â”‚   â”œâ”€â”€ lib/         # UtilitÃ¡rios

â”‚   â”‚   â”‚   â”œâ”€â”€ config/      # ConfiguraÃ§Ãµes

â”‚   â”‚   â”‚   â””â”€â”€ server.ts    # Entry point

â”‚   â”‚   â”œâ”€â”€ prisma/

â”‚   â”‚   â”‚   â””â”€â”€ schema.prisma

â”‚   â”‚   â””â”€â”€ package.json

â”‚   â”‚

â”‚   â””â”€â”€ web/                 # Frontend Next.js

â”‚       â”œâ”€â”€ src/

â”‚       â”‚   â”œâ”€â”€ app/         # App Router pages

â”‚       â”‚   â”œâ”€â”€ components/  # Componentes React

â”‚       â”‚   â”œâ”€â”€ lib/         # UtilitÃ¡rios

â”‚       â”‚   â””â”€â”€ hooks/       # Custom hooks

â”‚       â””â”€â”€ package.json

â”‚

â”œâ”€â”€ packages/                # CÃ³digo compartilhado (futuro)

â”‚   â””â”€â”€ shared/

â”‚

â”œâ”€â”€ package.json             # Monorepo root

â”œâ”€â”€ turbo.json               # Turborepo config

â””â”€â”€ README.md

```



---



\## ğŸ“¦ Funcionalidades por Fase



\### Fase 1: MVP â€” Uptime Monitoring (COMEÃ‡AR AQUI)



\#### 1.1 AutenticaÃ§Ã£o

\- \[ ] Registro de usuÃ¡rio (email + senha)

\- \[ ] Login com JWT

\- \[ ] Logout

\- \[ ] RecuperaÃ§Ã£o de senha (email)



\#### 1.2 Monitors (VerificaÃ§Ã£o de Uptime)

\- \[ ] CRUD de monitors (criar, listar, editar, deletar)

\- \[ ] Tipos de verificaÃ§Ã£o: HTTP/HTTPS

\- \[ ] Configurar intervalo de verificaÃ§Ã£o (1min, 5min, 10min, 30min)

\- \[ ] Verificar status code esperado

\- \[ ] Verificar tempo de resposta (timeout)

\- \[ ] Verificar texto presente na resposta (opcional)

\- \[ ] HistÃ³rico de verificaÃ§Ãµes (Ãºltimas 24h, 7 dias, 30 dias)

\- \[ ] CÃ¡lculo de uptime percentage



\#### 1.3 Worker de VerificaÃ§Ã£o

\- \[ ] Job que roda em background

\- \[ ] Executa verificaÃ§Ãµes no intervalo configurado

\- \[ ] Salva resultado no banco (status, latÃªncia, timestamp)

\- \[ ] Detecta mudanÃ§a de estado (up â†’ down, down â†’ up)

\- \[ ] Dispara alerta quando estado muda



\#### 1.4 Sistema de Alertas

\- \[ ] Configurar canais de notificaÃ§Ã£o por monitor

\- \[ ] Alerta por email (Resend)

\- \[ ] Alerta por webhook (para integrar com Slack, Discord, etc)

\- \[ ] Cooldown entre alertas (evitar spam)



\#### 1.5 Dashboard

\- \[ ] Lista de monitors com status atual

\- \[ ] Indicador visual (verde/vermelho/amarelo)

\- \[ ] GrÃ¡fico de latÃªncia (Ãºltimas 24h)

\- \[ ] GrÃ¡fico de uptime (Ãºltimos 7 dias)

\- \[ ] Filtros e busca



\### Fase 2: Status Pages

\- \[ ] Criar pÃ¡gina de status pÃºblica

\- \[ ] SubdomÃ­nio ou path customizado

\- \[ ] Selecionar quais monitors mostrar

\- \[ ] HistÃ³rico de incidentes pÃºblico

\- \[ ] Permitir inscriÃ§Ã£o para notificaÃ§Ãµes

\- \[ ] CustomizaÃ§Ã£o visual (logo, cores)



\### Fase 3: Incident Management

\- \[ ] Criar incidentes manualmente

\- \[ ] Incidentes automÃ¡ticos quando monitor cai

\- \[ ] Timeline do incidente

\- \[ ] AtualizaÃ§Ãµes de status (investigating, identified, fixed)

\- \[ ] Postmortem



\### Fase 4: Logs (Futuro)

\- \[ ] API de ingestÃ£o de logs

\- \[ ] Busca e filtros

\- \[ ] Alertas baseados em padrÃµes



\### Fase 5: Multi-tenancy e ComercializaÃ§Ã£o

\- \[ ] OrganizaÃ§Ãµes/Workspaces

\- \[ ] MÃºltiplos usuÃ¡rios por organizaÃ§Ã£o

\- \[ ] Planos e limites

\- \[ ] Billing (Stripe)



---



\## ğŸ—„ï¸ Modelos de Dados (Prisma Schema Inicial)



```prisma

generator client {

&nbsp; provider = "prisma-client-js"

}



datasource db {

&nbsp; provider = "postgresql"

&nbsp; url      = env("DATABASE\_URL")

}



model User {

&nbsp; id            String    @id @default(cuid())

&nbsp; email         String    @unique

&nbsp; name          String?

&nbsp; passwordHash  String

&nbsp; createdAt     DateTime  @default(now())

&nbsp; updatedAt     DateTime  @updatedAt

&nbsp; 

&nbsp; monitors      Monitor\[]

&nbsp; alertChannels AlertChannel\[]

}



model Monitor {

&nbsp; id              String        @id @default(cuid())

&nbsp; name            String

&nbsp; url             String

&nbsp; method          String        @default("GET")

&nbsp; intervalSeconds Int           @default(300)  // 5 minutos

&nbsp; timeout         Int           @default(30)   // segundos

&nbsp; expectedStatus  Int           @default(200)

&nbsp; checkSsl        Boolean       @default(true)

&nbsp; active          Boolean       @default(true)

&nbsp; 

&nbsp; createdAt       DateTime      @default(now())

&nbsp; updatedAt       DateTime      @updatedAt

&nbsp; 

&nbsp; userId          String

&nbsp; user            User          @relation(fields: \[userId], references: \[id])

&nbsp; 

&nbsp; checks          Check\[]

&nbsp; alerts          Alert\[]

&nbsp; 

&nbsp; @@index(\[userId])

&nbsp; @@index(\[active])

}



model Check {

&nbsp; id          String   @id @default(cuid())

&nbsp; status      String   // "up" | "down" | "degraded"

&nbsp; statusCode  Int?

&nbsp; latency     Int?     // ms

&nbsp; error       String?

&nbsp; checkedAt   DateTime @default(now())

&nbsp; 

&nbsp; monitorId   String

&nbsp; monitor     Monitor  @relation(fields: \[monitorId], references: \[id], onDelete: Cascade)

&nbsp; 

&nbsp; @@index(\[monitorId, checkedAt])

}



model AlertChannel {

&nbsp; id        String   @id @default(cuid())

&nbsp; type      String   // "email" | "webhook" | "slack"

&nbsp; name      String

&nbsp; config    Json     // { email: "..." } ou { webhookUrl: "..." }

&nbsp; active    Boolean  @default(true)

&nbsp; 

&nbsp; createdAt DateTime @default(now())

&nbsp; updatedAt DateTime @updatedAt

&nbsp; 

&nbsp; userId    String

&nbsp; user      User     @relation(fields: \[userId], references: \[id])

&nbsp; 

&nbsp; alerts    Alert\[]

&nbsp; 

&nbsp; @@index(\[userId])

}



model Alert {

&nbsp; id              String       @id @default(cuid())

&nbsp; type            String       // "down" | "up" | "degraded"

&nbsp; message         String

&nbsp; sentAt          DateTime     @default(now())

&nbsp; 

&nbsp; monitorId       String

&nbsp; monitor         Monitor      @relation(fields: \[monitorId], references: \[id], onDelete: Cascade)

&nbsp; 

&nbsp; alertChannelId  String

&nbsp; alertChannel    AlertChannel @relation(fields: \[alertChannelId], references: \[id])

&nbsp; 

&nbsp; @@index(\[monitorId, sentAt])

}



model Incident {

&nbsp; id          String   @id @default(cuid())

&nbsp; title       String

&nbsp; status      String   // "investigating" | "identified" | "monitoring" | "resolved"

&nbsp; severity    String   // "minor" | "major" | "critical"

&nbsp; startedAt   DateTime @default(now())

&nbsp; resolvedAt  DateTime?

&nbsp; 

&nbsp; createdAt   DateTime @default(now())

&nbsp; updatedAt   DateTime @updatedAt

&nbsp; 

&nbsp; updates     IncidentUpdate\[]

}



model IncidentUpdate {

&nbsp; id          String   @id @default(cuid())

&nbsp; message     String

&nbsp; status      String

&nbsp; createdAt   DateTime @default(now())

&nbsp; 

&nbsp; incidentId  String

&nbsp; incident    Incident @relation(fields: \[incidentId], references: \[id], onDelete: Cascade)

&nbsp; 

&nbsp; @@index(\[incidentId])

}

```



---



\## ğŸ”Œ Endpoints da API (Fase 1)



\### Auth

```

POST   /auth/register     - Criar conta

POST   /auth/login        - Login (retorna JWT)

POST   /auth/logout       - Logout

POST   /auth/forgot       - Solicitar reset de senha

POST   /auth/reset        - Resetar senha

GET    /auth/me           - Dados do usuÃ¡rio logado

```



\### Monitors

```

GET    /monitors          - Listar monitors do usuÃ¡rio

POST   /monitors          - Criar monitor

GET    /monitors/:id      - Detalhes do monitor

PUT    /monitors/:id      - Atualizar monitor

DELETE /monitors/:id      - Deletar monitor

GET    /monitors/:id/checks - HistÃ³rico de verificaÃ§Ãµes

POST   /monitors/:id/test   - Testar monitor manualmente

```



\### Alert Channels

```

GET    /alert-channels        - Listar canais

POST   /alert-channels        - Criar canal

PUT    /alert-channels/:id    - Atualizar canal

DELETE /alert-channels/:id    - Deletar canal

POST   /alert-channels/:id/test - Testar canal

```



\### Dashboard

```

GET    /dashboard/summary     - Resumo (total monitors, up, down, uptime mÃ©dio)

GET    /dashboard/timeline    - Timeline de eventos recentes

```



---



\## âš™ï¸ VariÃ¡veis de Ambiente



```env

\# Database

DATABASE\_URL="postgresql://user:pass@localhost:5432/monitoring"



\# Redis

REDIS\_URL="redis://localhost:6379"



\# JWT

JWT\_SECRET="sua-chave-secreta-muito-segura"

JWT\_EXPIRES\_IN="7d"



\# Email (Resend)

RESEND\_API\_KEY="re\_xxxx"

EMAIL\_FROM="alerts@seudominio.com"



\# App

NODE\_ENV="development"

API\_PORT=3333

WEB\_URL="http://localhost:3000"

API\_URL="http://localhost:3333"

```



---



\## ğŸ“ InstruÃ§Ãµes para o Claude



1\. \*\*Sempre use TypeScript\*\* com tipagem estrita

2\. \*\*Comente o cÃ³digo\*\* explicando a lÃ³gica principal

3\. \*\*Siga o padrÃ£o de pastas\*\* definido na arquitetura

4\. \*\*Use tratamento de erros\*\* adequado com try/catch

5\. \*\*Valide inputs\*\* com Zod em todos os endpoints

6\. \*\*Crie testes\*\* pelo menos para a lÃ³gica de negÃ³cio principal

7\. \*\*Use variÃ¡veis de ambiente\*\* para configuraÃ§Ãµes sensÃ­veis

8\. \*\*Siga RESTful\*\* nos endpoints da API

9\. \*\*Documente\*\* cada mÃ³dulo com um README se necessÃ¡rio



---



\## ğŸš€ PrÃ³ximos Passos Imediatos



1\. Inicializar monorepo com Turborepo

2\. Configurar projeto do backend (Fastify + TypeScript + Prisma)

3\. Configurar projeto do frontend (Next.js + Tailwind + shadcn)

4\. Implementar autenticaÃ§Ã£o

5\. Implementar CRUD de monitors

6\. Implementar worker de verificaÃ§Ã£o

7\. Implementar dashboard bÃ¡sico



---



\## ğŸ¤ Como Trabalhar



Vou desenvolver feature por feature. A cada etapa:

1\. Me mostre o cÃ³digo completo dos arquivos

2\. Explique o que cada parte faz

3\. Me diga como testar

4\. SÃ³ passe para prÃ³xima feature quando eu confirmar que funcionou



\*\*Estou pronto para comeÃ§ar. Inicie pela configuraÃ§Ã£o do monorepo e setup inicial do projeto.\*\*

